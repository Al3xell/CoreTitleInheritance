#All of these assume that you have checked that it is proper to call them before making the call.


apply_core_holding_province_modifier = { # scope is a title
    if = {
        limit = {is_title_holding = yes}
        title_province = {
            if = {
                limit = {
                    AND = {
                        has_game_rule = overtime_core_holding_cost
                        has_game_rule = control_core_holding_benefit
                    }
                }
                add_province_modifier = core_province_cost_benefit_modifier
            }
            else if = {
                limit = {
                    has_game_rule = overtime_core_holding_cost
                }
                add_province_modifier = core_province_cost_modifier
            }
            else if = {
                limit = {
                    has_game_rule = control_core_holding_benefit
                }
                add_province_modifier = core_province_benefit_modifier
            }
        }
    }
}

remove_core_holding_province_modifier = { # scope is a title
    if = {
        limit = {is_title_holding = yes}
        title_province = {
            remove_all_province_modifier_instances = core_province_cost_benefit_modifier
            remove_all_province_modifier_instances = core_province_cost_modifier
            remove_all_province_modifier_instances = core_province_benefit_modifier
        }
    }
}

initialize_core_province_modifiers = { # scope is a character
    every_core_holding = {
        remove_core_holding_province_modifier
        apply_core_holding_province_modifier
    }
}

set_over_core_limit_modifier = { # scope is character
    remove_all_character_modifier_instances = 1_over_core_limit_modifier
    remove_all_character_modifier_instances = 2_over_core_limit_modifier
    remove_all_character_modifier_instances = 3_over_core_limit_modifier
    remove_all_character_modifier_instances = 4_over_core_limit_modifier
    remove_all_character_modifier_instances = 5_over_core_limit_modifier
    remove_all_character_modifier_instances = 6_over_core_limit_modifier
    remove_all_character_modifier_instances = 7_over_core_limit_modifier
    remove_all_character_modifier_instances = 8_over_core_limit_modifier
    remove_all_character_modifier_instances = 9_over_core_limit_modifier
    remove_all_character_modifier_instances = 10+_over_core_limit_modifier
    ammount_over_core_limit = {save_temorary_scope_as = amount_over_core_limit} #hopefully stores the variable so it is not calculated every time.
    if = {
        limit = {scope:amount_over_core_limit = 0}
        # do nothing
    }
    else if = {
        limit = {scope:amount_over_core_limit = 1}
        add_character_modifier = 1_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 2}
        add_character_modifier = 2_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 3}
        add_character_modifier = 3_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 4}
        add_character_modifier = 4_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 5}
        add_character_modifier = 5_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 6}
        add_character_modifier = 6_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 7}
        add_character_modifier = 7_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 8}
        add_character_modifier = 8_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit = 9}
        add_character_modifier = 9_over_core_limit_modifier
    }
    else if = {
        limit = {scope:amount_over_core_limit >= 10}
        add_character_modifier = 10+_over_core_limit_modifier
    }
}


initialize_core_count = {# scope is a character
    set_variable = {
        name = core_count
        value = core_count_from_list
    }
    set_over_core_limit_modifier
}


increment_core_count = {# scope is character
    change_variable = {
        name = core_count
        add = 1
    }
    set_over_core_limit_modifier
}

# assumes that core count is 
decrement_core_count = {# scope is character
    change_variable = {
        name = core_count
        subtract = 1
    }
    set_over_core_limit_modifier
}

apply_cost_and_count_of_title = { # scope is title. Additionaly expects a value and a boolean.
    if = {
        limit = {is_title_holding = yes}
        if = {
            limit = {NOT = {exists = var:core_count}}
            initialize_core_count
        }
        else if = {
            limit = {$INCREASE$ = yes}
            holder = increment_core_count# Think this should apply this with scope holder
            apply_core_holding_province_modifier # redundant check for being a holding in this case. checks game rules in here.
        }
        else = {
            holder = decrement_core_count# Think this should apply this with scope holder
            remove_core_holding_province_modifier# redundant check for being a holding in this case. checks game rules in here.
        }
        if = {
            limit = {has_game_rule = flat_designate_core_holding_cost }
            holder = {add_prestige = $COST$}
        }
    }
}

#unlike making titles no longer be core, cores should only be made by being designated. Cannot core beyond core title limit.
designate_core_title = {#scope is title
    set_variable = {
        name = core
        value = yes
    }
    set_always_follows_primary_heir = yes
    apply_cost_and_count_of_title = {
        INCREASE = yes
        COST = coring_holding_cost_flat
    }
}

de_designate_core_title = {# scope is title
    de_core_title
    apply_cost_and_count_of_title = {
        INCREASE = no
        COST = coring_holding_refund_flat
    } 
}

#This should not be used to remove bad core titles on inheritance. On inheritance, core titles should not be broken (though capital chain and primary might be removed or changed)
# should be able to construct list and use it in the limit for the next one.
remove_invalid_core_titles = { #scope is a character. full refund. should happen when a core title is lost if it invalidates the heirarchy
    send_cores_removed_toast
    while = {# Essentially while list is not empty
        limit = {any_inconsistent_core_title = {always = no}}# Should fix this later, it in essense calculates the list twice as often as it needs to
        every_inconsistent_core_title = { # this should be the title here, and root the character
            if = {
                limit = {can_de_core_title = yes} # This means this can technically go into an infinite loop, but this should never happen.
                de_core_title
                apply_cost_and_count_of_title = {
                    INCREASE = no
                    COST = coring_holding_refund_flat_full
                }
            }
        }
    }
}

safe_de_core_title = {
    if = {
        limit = {can_de_core_title = yes}
        de_core_title
    }
}

de_core_title = { # scope is a title. Will still work even if title is not core.
    set_variable = {
        name = core
        value = no
    }
    set_always_follows_primary_heir = no
}

recalculate_cores = { # scope is a character. this is used in cases like inheritance when core titles are preserved
    initialize_core_count
    initialize_core_province_modifiers
    if = {
        limit = {any_core_title = {is_core_consistent = no}}
        remove_invalid_core_titles
    }
}

# Should never be needed
#remove_all_core_titles = {# scope is character. full refund. this should be used if something brings one over core limit - currently ther is no penalty for being over.
#    save_temporary_scope_as = this_character
#    every_core_title = {
#        if = {
#            limit = {can_de_core_title}
#            decore_title
#            apply_cost_and_count_of_title = {
#                INCREASE = no
#                COST = coring_title_refund_flat_full
#            }
#        }
#    }
#}

de_designate_all_core_titles = { #scope is character not full refund. should be called by a decision
    every_core_title = {
        if = {
            limit = {can_de_core_title = yes}
            decore_title
            apply_cost_and_count_of_title = {
                INCREASE = no
                COST = coring_holding_refund_flat
            }
        }
    }
}

send_cores_removed_toast = { # scope should not be needed
    send_interface_toast = {
        type = event_toast_text_bad # possibly change to msg_title_rank_down
        title = cores_titles_removed_toast_title
        desc = cores_titles_removed_toast_desc
    }
}